/**
 * Groups the elements of an iterable in an array by a key and organizes the
 * arrays in a map. The map's keys are generated by a selector which can either
 * be a function or a key for any property on the elements. The selector
 * function (if provided) is invoked with one argument (the current value).
 *
 * Examples:
 *
 * ```typescript
 * const input = [
 *   { x: 0, y: "a" },
 *   { x: 1, y: "b" },
 *   { x: 2, y: "a" },
 *   { x: 3, y: "c" },
 *   { x: 4, y: "b" },
 * ];
 *
 * const fromProperty = groupBy(input, "y");
 * // returns: Map {
 * //   "a" => [{ x: 0, y: "a" }, { x: 2, y: "a" }],
 * //   "b" => [{ x: 1, y: "b" }, { x: 4, y: "b" }],
 * //   "c" => [{ x: 3, y: "c" }],
 * // }
 *
 * const fromFunction = groupBy(input, (value) => value.y.charCodeAt(0) % 2)
 * // returns: Map {
 * //   1 => [{ x: 0, y: "a" }, { x: 2, y: "a" }, { x: 3, y: "c" }],
 * //   0 => [{ x: 1, y: "b" }, { x: 4, y: "b" }, { x: 5, y: "b" }],
 * // }
 * ```
 */
export function groupBy<T, Key extends keyof T>(
  input: Iterable<T>,
  selector: Key
): Map<T[Key], T[]>;
export function groupBy<T, Key>(
  input: Iterable<T>,
  selector: (element: T, index: number) => Key
): Map<Key, T[]>;
export function groupBy(input: Iterable<any>, selector: any): Map<any, any> {
  const result = new Map();
  const keySelector =
    typeof selector === "function" ? selector : (x: any) => x[selector];
  let i = 0;
  for (const element of input) {
    const key = keySelector(element, i++);
    const values = result.get(key);
    if (values) {
      values.push(element);
    } else {
      result.set(key, [element]);
    }
  }
  return result;
}

/**
 * Organizes the elements of an iterable in a map. The map's keys are generated
 * by a selector which can either be a function or a key for any property on the
 * elements. The selector function (if provided) is invoked with one argument
 * (the current value). If the selector function produces the same key twice, it
 * will throw an error.
 *
 * Examples:
 *
 * ```typescript
 * ```
 */
export function mapBy<T, Key extends keyof T>(
  values: Iterable<T>,
  selector: Key
): Map<T[Key], T>;
export function mapBy<T, Key>(
  values: Iterable<T>,
  selector: (arg: T) => Key
): Map<Key, T>;
export function mapBy(values: Iterable<any>, selector: any): Map<any, any> {
  const result = new Map();
  const keySelector =
    typeof selector === "function" ? selector : (x: any) => x[selector];
  for (const value of values) {
    const key = keySelector(value);
    if (result.has(key)) {
      throw new Error(
        `mapBy(): Key "${key}" already exists for value "${value}"`
      );
    }
    result.set(key, value);
  }
  return result;
}

/**
 * Splits an iterable into two groups. The first group contains elements
 * the predicate function returns truthy for, the second group contains elements
 * the predicate returns falsey for. The predicate is invoked with one argument
 * (the current value).
 *
 * Examples:
 *
 * ```typescript
 * ```
 */
export function partition<T>(
  input: Iterable<T>,
  predicate: (element: T) => boolean
): [T[], T[]];
export function partition<T, U>(
  input: Iterable<T | U>,
  predicate: (element: T | U) => element is T
): [T[], U[]];
export function partition<T>(
  input: Iterable<T>,
  predicate: (element: T) => boolean
): [T[], T[]] {
  const a = [];
  const b = [];
  for (const element of input) {
    if (predicate(element)) {
      a.push(element);
    } else {
      b.push(element);
    }
  }
  return [a, b];
}
